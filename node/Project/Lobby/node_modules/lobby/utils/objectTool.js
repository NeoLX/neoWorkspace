 (function() {  
       // initializing变量用来标示当前是否处于类的创建阶段，  
         
       var initializing = false, fnTest = /xyz/.test(function() { xyz; }) ? /\b_super\b/ : /.*/;  
       // 基类构造函数  
       // 这里的this是window，所以这整段代码就向外界开辟了一扇窗户 - window.Class  
       this.Class = function() { };  
       // 继承方法定义  
       Class.extend = function(prop) {  
            
           var _super = this.prototype;  
           // 通过将子类的原型指向父类的一个实例对象来完成继承  
           // - 注意：this是基类构造函数（即是Class）  
           initializing = true;  
           var prototype = new this();  
           initializing = false;  
           for (var name in prop) {  
               prototype[name] = typeof prop[name] == "function" && typeof _super[name] == "function"  ?  
                       (function(name, fn) {  
                           return function() {  
                               var tmp = this._super;  
                               this._super = _super[name];  
                               var ret = fn.apply(this, arguments);  
  
                               return ret;  
                           };  
                       })(name, prop[name]) :  
                       prop[name];  
           }  
             
           function Class() {  
               // 在类的实例化时，调用原型方法init  
               if (!initializing && this.init)  
                   this.init.apply(this, arguments);  
           }  
           // 子类的prototype指向父类的实例（完成继承的关键）  
           Class.prototype = prototype;  
           // 修正constructor指向错误  
           Class.constructor = Class;  
           // 子类自动获取extend方法，arguments.callee指向当前正在执行的函数  
           Class.extend = arguments.callee;  
           return Class;  
       };  
   })();  


module.exports = Class;